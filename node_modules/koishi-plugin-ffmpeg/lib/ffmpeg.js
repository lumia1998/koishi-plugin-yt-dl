"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FFmpeg = exports.FFmpegBuilder = void 0;
const koishi_1 = require("koishi");
const child_process_1 = require("child_process");
const stream_1 = require("stream");
class FFmpegBuilder {
    constructor(executable) {
        this.executable = executable;
        this.inputOptions = [];
        this.outputOptions = [];
    }
    input(arg) {
        this._input = arg;
        return this;
    }
    inputOption(...option) {
        this.inputOptions.push(...option);
        return this;
    }
    outputOption(...option) {
        this.outputOptions.push(...option);
        return this;
    }
    run(type, path) {
        const options = ['-y'];
        if (typeof this._input === 'string') {
            options.push(...[...this.inputOptions, '-i', this._input]);
        }
        else {
            options.push(...[...this.inputOptions, '-i', '-']);
        }
        if (type === 'file') {
            options.push(...[...this.outputOptions, path]);
        }
        else if (type !== 'info') {
            options.push(...[...this.outputOptions, '-']);
        }
        const child = (0, child_process_1.spawn)(this.executable, options, { stdio: 'pipe' });
        if (this._input instanceof Buffer) {
            child.stdin.write(this._input);
            child.stdin.end();
        }
        else if (this._input instanceof stream_1.Readable) {
            this._input.pipe(child.stdin);
        }
        // TODO: pipe stderr to logger
        // https://github.com/shigma/reggol/issues/7
        if (type === 'stream') {
            return child.stdout;
        }
        else {
            return new Promise((resolve, reject) => {
                child.stdin.on('error', function (err) {
                    if (!['ECONNRESET', 'EPIPE', 'EOF'].includes(err['code']))
                        reject(err);
                });
                child.on('error', reject);
                let stream;
                if (type === 'file') {
                    child.on('exit', code => code === 0 ? resolve() : reject(new Error(`exited with ${code}`)));
                }
                else if (type === 'buffer') {
                    stream = child.stdout;
                }
                else if (type === 'info') {
                    stream = child.stderr;
                }
                if (stream) {
                    const buffer = [];
                    stream.on('data', data => buffer.push(data));
                    stream.on('end', () => resolve(Buffer.concat(buffer)));
                    stream.on('error', reject);
                }
            });
        }
    }
}
exports.FFmpegBuilder = FFmpegBuilder;
class FFmpeg extends koishi_1.Service {
    constructor(ctx, executable) {
        super(ctx, 'ffmpeg');
        this.executable = executable;
    }
    builder() {
        return new FFmpegBuilder(this.executable);
    }
}
exports.FFmpeg = FFmpeg;
